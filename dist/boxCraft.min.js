class $fca228c3af8a0080$export$a829527ff4e4114a {
    // Static canvas list shared by all instances
    // static canvasList = [];
    constructor(element, callback){
        // The base image element
        this.element = element;
        this.callback = callback;
    }
    //we need this init to avoid the creation of extra canvas onload
    init() {
        // Common properties for selection tools could be initialized here
        // Create a new canvas element
        this.overlayCanvas = document.createElement("canvas");
        // Set the dimensions of the canvas to match the base image
        this.overlayCanvas.width = this.element.width;
        this.overlayCanvas.height = this.element.height;
        // Style the canvas to overlay the base image
        this.overlayCanvas.style.position = "absolute";
        this.overlayCanvas.style.left = this.element.offsetLeft + "px";
        this.overlayCanvas.style.top = this.element.offsetTop + "px";
        this.overlayCanvas.style.zIndex = "1000"; // High value to ensure it's on top
        this.ctx = this.overlayCanvas.getContext("2d");
        this.ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        // Append the overlay canvas to the same parent element as the base image
        this.element.parentElement.appendChild(this.overlayCanvas);
    // Add this.overlayCanvas to canvasList
    // BoxCraft.canvasList.push(this.overlayCanvas);
    }
    hideLastCanvas() {
        if (BoxCraft.canvasList.length > 0) {
            let lastCanvas = BoxCraft.canvasList.pop();
            // lastCanvas.style.display = 'none'; // Hide the canvas
            lastCanvas.remove(); // to completely remove the element
        }
    }
    hide() {}
}



class $f52c7bfdf3db710e$export$dd23631818154ff extends (0, $fca228c3af8a0080$export$a829527ff4e4114a) {
    constructor(element, callback){
        super(element, callback);
        this.rect = {};
        this.handleRadius = 1;
        this.dragTL = this.dragBL = this.dragTR = this.dragBR = false;
        this.dragWholeRect = false;
        console.log("hello");
        super.init();
        this.initRect();
        this.drawRectInCanvas();
        this.attachResizeListeners();
    }
    initRect() {
        this.rect.height = 200;
        this.rect.width = 200;
        this.rect.left = (window.innerWidth - this.rect.width) / 2;
        this.rect.top = (window.innerHeight - this.rect.height) / 2;
    }
    drawRectInCanvas() {
        var ctx = this.overlayCanvas.getContext("2d");
        ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        ctx.beginPath();
        ctx.lineWidth = "1";
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeStyle = "#000000";
        ctx.rect(this.rect.left, this.rect.top, this.rect.width, this.rect.height);
        ctx.fill();
        ctx.stroke();
    }
    attachResizeListeners() {
        this.overlayCanvas.addEventListener("mousedown", this.mouseDown.bind(this), false);
        this.overlayCanvas.addEventListener("mouseup", this.mouseUp.bind(this), false);
        this.overlayCanvas.addEventListener("mousemove", this.mouseMove.bind(this), false);
    }
    mouseDown(e) {
        // ... implementation of mouseDown
        let pos = this.getMousePos(e);
        let mouseX = pos.x;
        let mouseY = pos.y;
        // 0. inside movable rectangle
        if (this.checkInRect(mouseX, mouseY, this.rect)) {
            this.dragWholeRect = true;
            this.startX = mouseX;
            this.startY = mouseY;
        } else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top)) this.dragTL = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top)) this.dragTR = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.dragBL = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.dragBR = true;
        this.drawRectInCanvas();
    }
    // Add the rest of the helper functions like getMousePos, checkInRect, checkCloseEnough here.
    getMousePos(evt) {
        let clx = evt.clientX;
        let cly = evt.clientY;
        let boundingRect = this.element.getBoundingClientRect();
        return {
            x: clx - boundingRect.left,
            y: cly - boundingRect.top
        };
    }
    checkInRect(x, y, r) {
        return x > r.left && x < r.width + r.left && y > r.top && y < r.top + r.height;
    }
    checkCloseEnough(p1, p2) {
        return Math.abs(p1 - p2) < this.handleRadius;
    }
    mouseMove(e) {
        let pos = this.getMousePos(e);
        let mouseX = pos.x;
        let mouseY = pos.y;
        // Update the cursor style based on mouse position
        this.updateCursorStyle(mouseX, mouseY);
        if (this.dragWholeRect) {
            e.preventDefault();
            e.stopPropagation();
            let dx = mouseX - this.startX;
            let dy = mouseY - this.startY;
            if (this.rect.left + dx > 0 && this.rect.left + dx + this.rect.width < this.overlayCanvas.width) this.rect.left += dx;
            if (this.rect.top + dy > 0 && this.rect.top + dy + this.rect.height < this.overlayCanvas.height) this.rect.top += dy;
            this.startX = mouseX;
            this.startY = mouseY;
        } else if (this.dragTL) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(this.rect.left + this.rect.width - mouseX) + Math.abs(this.rect.height + this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.left = this.rect.left + this.rect.width - newSide;
                this.rect.top = this.rect.height + this.rect.top - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragTR) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(mouseX - this.rect.left) + Math.abs(this.rect.height + this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.top = this.rect.height + this.rect.top - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragBL) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(this.rect.left + this.rect.width - mouseX) + Math.abs(this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.left = this.rect.left + this.rect.width - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragBR) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(mouseX - this.rect.left) + Math.abs(mouseY - this.rect.top)) / 2;
            if (newSide > 150) this.rect.width = this.rect.height = newSide;
        }
        this.drawRectInCanvas();
    }
    updateCursorStyle(mouseX, mouseY) {
        if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top)) this.overlayCanvas.style.cursor = "nwse-resize"; // Top left corner
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top)) this.overlayCanvas.style.cursor = "nesw-resize"; // Top right corner
        else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.overlayCanvas.style.cursor = "nesw-resize"; // Bottom left corner
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.overlayCanvas.style.cursor = "nwse-resize"; // Bottom right corner
        else this.overlayCanvas.style.cursor = "default"; // Default cursor elsewhere
    }
    mouseUp(e) {
        this.dragTL = this.dragTR = this.dragBL = this.dragBR = false;
        this.dragWholeRect = false;
        this.storeCoordinates();
    }
    storeCoordinates() {
        // ... implementation of storeCoordinates
        let topleft = {
            x: this.rect.left,
            y: this.rect.top
        };
        let bottomright = {
            x: this.rect.left + this.rect.width,
            y: this.rect.top + this.rect.height
        };
        // console.log("Top Left:", topleft, "Bottom Right:", bottomright);
        this.callback(topleft, bottomright); // Invoke the callback with the coordinates
    }
} // Usage:
 // Assuming `callback` is a function that handles the top-left and bottom-right coordinates
 // And `element` is the canvas element to which the bounding box should be applied
 //   let element = document.getElementById('canvas');
 //   let resizableBox = new ResizableBBox(element);
 //   resizableBox.init();


class $5018ea9c30d774e7$export$247262aa28c26769 {
    constructor(){}
    createResizableBBox(element, callback) {
        return new (0, $f52c7bfdf3db710e$export$dd23631818154ff)(element, callback);
    }
}



// import { ResizableBBox } from "./widgets/resizableBBox.js";
// import { DraggableBBox } from "./widgets/draggableBBox.js";
// register global namespace with a new BoxCraft instance
window.BoxCraft = new (0, $5018ea9c30d774e7$export$247262aa28c26769)();
// window.BoxCraft.ResizableBBox = ResizableBBox;
window.console.log("BoxCraft VERSION 0.1-alpha");


//# sourceMappingURL=boxCraft.min.js.map
